# AI 对话记录：2026-02-11

- 主题：完成 ch4/ch5 编程作业（trace/mmap/munmap、spawn、stride 调度等），修复多处关键问题
- 使用的 AI 工具：GitHub Copilot（VS Code Agent Mode）

## 关键结论

- ch4 exercise 测试 16/16 通过，base 测试 6/6 通过。
- ch5 exercise 测试 17/17 通过（`./test.sh exercise`）。
- 从 Reference/ch4 复制到 Work/os/ch4，完成 workspace 依赖整合；ch5 同步实现 spawn、stride 调度与 mmap/munmap。
- `tg-kernel-vm` 拉取到 `Work/crates/tg-kernel-vm`，补齐 `unmap()`、`find_pte_mut()`、`PageManager::deallocate()`，确保地址空间释放完整。
- 解决了**三个 bug**（ch4）：启动栈溢出、调度栈溢出、trace 权限检查缺少 U 位；ch5 中完成 stride 调度实现与调度公平性验证。

---

## ch4 编程作业实现过程

### 任务目标

1. **重写 trace 系统调用**（ID 410）：引入虚存后需通过 `translate()` 翻译用户地址，并检查权限。
2. **实现 mmap**（ID 222）：申请物理内存映射到用户虚存，支持 R/W/X 权限。
3. **实现 munmap**（ID 215）：取消虚存映射，要求所有页已被映射。

### 项目搭建

1. 从 `Reference/ch4` 复制到 `Work/os/ch4`
2. 修改 `Cargo.toml`：包名 `tg-ch4` → `ch4`，依赖改为 workspace 引用
3. `tg-kernel-vm` 拉取到 `Work/crates/tg-kernel-vm`，在 workspace 中统一管理

### 修改的文件

#### 1. `Work/os/ch4/src/process.rs` — 扩展 Process 结构体

- 新增 `pub syscall_counts: [usize; SYSCALL_COUNT_MAX]`（`SYSCALL_COUNT_MAX = 512`）
- 新增 `record_syscall(&mut self, id: SyscallId)`：按 ID 索引递增
- 新增 `syscall_count(&self, id: usize) -> Option<usize>`：查询调用次数

与 ch3 的区别：ch3 通过 `Caller.entity` 指针传递计数数组，ch4 直接存在 `Process` 结构体中，通过 `PROCESSES` 全局列表访问。

#### 2. `Work/os/ch4/src/main.rs` — 实现三个系统调用 + 修复三个 bug

**Trace 实现：**
```rust
impl Trace for SyscallContext {
    fn trace(&self, caller: Caller, trace_request: usize, id: usize, data: usize) -> isize {
        const READABLE: VmFlags<Sv39> = build_flags("U__RV");
        const WRITABLE: VmFlags<Sv39> = build_flags("U_W_V");
        match trace_request {
            0 => process.address_space.translate::<u8>(VAddr::new(id), READABLE)
                    .map(|ptr| unsafe { *ptr.as_ptr() as isize }).unwrap_or(-1),
            1 => /* translate + write */,
            2 => process.syscall_count(id).map(|c| c as isize).unwrap_or(-1),
            _ => -1,
        }
    }
}
```

**mmap 实现：**
- 参数校验：addr 页对齐、prot 合法（`prot & !0x7 == 0` 且 `prot & 0x7 != 0`）
- 权限构建：`prot` 的 bit0/1/2 分别对应 R/W/X，转为 `"U___V"` 格式字符串再 `parse_flags()`
- 重叠检查：遍历 `address_space.areas` 判断 `[start_vpn, end_vpn)` 是否与已有区域重叠
- 调用 `address_space.map(range, &[], 0, flags)` 分配零页并映射

**munmap 实现：**
- 逐页检查是否在 `address_space.areas` 中存在映射，未映射则返回 -1
- 调用 `address_space.unmap(range)` 取消映射

#### 3. `Work/crates/tg-kernel-vm/src/space/mod.rs` — 新增 unmap 方法

```rust
pub fn unmap(&mut self, range: Range<VPN<Meta>>) {
    // 1. 从 areas 中移除范围（支持拆分）
    // 2. 逐页清除 PTE（find_pte_mut + write_bytes 清零）
    // 3. sfence.vma 刷新 TLB
}

fn find_pte_mut(&self, vpn: VPN<Meta>) -> Option<*mut Pte<Meta>> {
    // 三级页表遍历：从根页表沿 VPN[2] → VPN[1] → VPN[0] 找到叶子 PTE
}
```

### 踩坑记录

#### Bug 1：启动栈溢出（只检测到 1 个 app，然后卡死）

**现象**：`cargo run` 只打印 `detect app[0]`，然后无输出卡死。

**原因**：`Process` 结构体含 `syscall_counts: [usize; 512]` = 4KB。`Process::new()` 在栈上构造临时 `Process` 再 `Vec::push()`，原始启动栈 `6 * 4096 = 24KB` 不足。

**修复**：
```rust
// boot0! 宏：内核启动栈 24KB → 64KB
tg_linker::boot0!(rust_main; stack = 16 * 4096);
```

**教训**：ch3 也遇到过相同问题。含大数组的结构体在栈上临时构造时很容易溢出，裸机环境下栈溢出无任何提示，只会静默卡死。

#### Bug 2：调度线程栈溢出（StorePageFault）

**现象**：所有 app 检测成功，但进入 `schedule()` 后立即触发 `StorePageFault`，`stval` 接近 `0x4000000000`（调度栈顶）。

**原因**：调度栈原来只有 2 页（8KB），`schedule()` 函数的调用链（传送门切换 → syscall 分发 → trace/mmap 处理）栈深度超过 8KB。

**修复过程**：
- 先尝试 4 页 → 仍然 crash（`stval = 0x3fffffbff8`，距栈顶 16KB 处溢出）
- 最终增至 8 页（32KB）→ 正常运行

```rust
const SCHED_PAGES: usize = 8;
const PAGE: Layout = unsafe {
    Layout::from_size_align_unchecked(SCHED_PAGES << Sv39::PAGE_BITS, 1 << Sv39::PAGE_BITS)
};
```

#### Bug 3：trace 权限检查缺少 U 位（ch4_trace 断言失败）

**现象**：`ch4_trace` 测试中 `trace_read(isize::MAX)` 返回 `Some(0)` 而非 `None`。预期对用户不可见地址返回 -1。

**分析**：
- `isize::MAX = 0x7FFFFFFFFFFFFFFF`
- Sv39 虚拟地址只有 39 位，高位被截断 → 映射到 `VPN::MAX`
- `VPN::MAX` 恰好是**异界传送门页面**（`PROTAL_TRANSIT`）
- 传送门标志位为 `"__G_XWRV"`（无 U 位），内核可访问但用户不可见
- 原始 `READABLE = build_flags("RV")` 只检查 R+V，不检查 U → translate 成功

**修复**：
```rust
// 之前：只检查 R+V
const READABLE: VmFlags<Sv39> = build_flags("RV");
const WRITABLE: VmFlags<Sv39> = build_flags("W_V");

// 之后：必须检查 U 位，确保用户态可见
const READABLE: VmFlags<Sv39> = build_flags("U__RV");
const WRITABLE: VmFlags<Sv39> = build_flags("U_W_V");
```

**教训**：`translate()` 的 `flags.contains()` 检查要求被检查标志位是 PTE 标志的**子集**。不带 U 位检查时，传送门页面（有 R+V 但无 U）也会通过，造成安全漏洞。

### 设计对比：ch3 vs ch4 的 trace

| 方面 | ch3（无虚存） | ch4（Sv39 虚存） |
|------|-------------|-----------------|
| 地址含义 | 物理地址 | 虚拟地址 |
| 读取方式 | 直接解引用指针 | `translate()` 翻译 + 权限检查 |
| 权限检查 | 无 | 必须包含 U 位 |
| 计数传递 | `Caller.entity` 编码指针 | `PROCESSES` 全局列表索引 |
| 失败情况 | 理论上不会 | 地址不可见/权限不足返回 -1 |

### 测试结果

```
# exercise 测试
$ ./test.sh exercise
[PASS] found <Test trace OK!>
[PASS] found <Test mmap OK!>
... (共 16 项)
Test PASSED: 16/16
✓ ch4 练习测试通过

# base 测试
$ ./test.sh base
[PASS] found <Hello, world from user mode program!>
[PASS] found <Test power OK!>
... (共 6 项)
Test PASSED: 6/6
✓ ch4 基础测试通过
```

## 技术要点总结

### VmFlags 字符串格式

```
位置：  U  X  W  R  V
示例： "U__RV"  → 用户可读有效
       "U_W_V"  → 用户可写有效
       "UXWRV"  → 用户全权限
       "__G_XWRV" → 全局内核全权限（传送门）
```

- `build_flags()` 编译期常量，`parse_flags()` 运行期解析
- `VmFlags::contains()` 检查被检查标志是 PTE 标志的子集

### AddressSpace 关键 API

| 方法 | 用途 |
|------|------|
| `map(range, data, offset, flags)` | 分配物理页 + 拷贝数据 + 建立映射 |
| `map_extern(range, ppn, flags)` | 已有物理页，仅建立映射 |
| `unmap(range)` | 取消映射，清除 PTE，刷新 TLB |
| `translate::<T>(vaddr, flags)` | 虚拟地址翻译 + 权限检查 |
| `areas` | `Vec<Range<VPN>>`，记录所有已映射区域 |

## 待办

- 阅读 ch5 exercise，开始下一章节的编程作业（fork/exec/waitpid）。

---

## ch5 编程作业实现过程

### 任务目标

1. **实现 spawn 系统调用**（ID 400）：直接按路径创建新进程，无需 fork 复制地址空间。
2. **实现 stride 调度算法**：为进程维护 `priority/stride`，调度最小 stride 进程，并新增 `set_priority` 系统调用（ID 140）。
3. **补齐 mmap/munmap** 迁移：在新的进程管理框架下复用第四章逻辑。
4. **完善页表管理**：实现 `PageManager::deallocate/drop_root` 以正确回收物理页。

### 核心改动

| 文件 | 关键修改 |
|------|-----------|
| `Work/os/ch5/src/process.rs` | 新增 `priority/stride` 字段、`BIG_STRIDE` 常量、`stride_step()`；`exec/fork` 保留或继承调度参数，`from_elf` 初始化默认优先级；提供调度步长计算。 |
| `Work/os/ch5/src/processor.rs` | 重写就绪队列为 `BinaryHeap<Reverse<ReadyEntry>>`，按 stride + FIFO 次序调度；`fetch()` 更新调度后 stride。 |
| `Work/os/ch5/src/main.rs` | 实现 `spawn`（翻译路径→装载 ELF→继承父调度设置）、`set_priority`、`mmap/munmap`、`Sv39Manager::deallocate/drop_root`；`spawn` 使用 `Vec` 缓冲路径并接入 `PManager::add`。 |

### 测试与验证

```
$ cargo check --features exercise
$ ./test.sh exercise
```

- `cargo check` 确认编译通过。
- `./test.sh exercise` 输出 17/17 PASS（含 stride、spawn、mmap/munmap 等所有测例）。

### 踩坑与经验

1. **就绪队列和 stride 更新**：
    - 初版尝试“归一化”所有 stride，导致唤醒阻塞进程后重复入队；最终改为每次 `fetch()` 后直接为选中进程累加 `stride_step()`。
    - 二叉堆键值使用 `Reverse<ReadyEntry>`，并用 `order` 字段打破 stride 相同导致的饥饿。
2. **spawn 路径解析**：
    - 用户缓冲区可能包含结尾 `\0`，通过 `position(|b| b == 0)` 截断；若路径为空或解析失败立即返回 -1。
    - 继承父进程 `priority/stride`，保持父子之间调度公平性。若不继承，spawn 出来的进程初始 stride 为 0 会短期内占据 CPU。
3. **PageManager::deallocate**：
    - 需要检查 PTE 是否带 `OWNED` 标记；仅回收内核分配的页，避免误释放恒等映射页面。
    - 与 `drop_root()` 一并使用 `dealloc`，确保分页器生命周期结束时没有内存泄漏。

### 技术要点总结

#### Stride 调度公式

- `stride += BIG_STRIDE / priority`；其中 `BIG_STRIDE = 1 << 20`，默认 `priority = 16`。
- `priority >= 2` 合法，`set_priority(prio < 2)` 返回 -1。
- `BinaryHeap<Reverse<ReadyEntry>>` 实现最小堆，比较顺序：`stride → order → pid`。

#### spawn 内部流程

1. 翻译用户态路径 → UTF-8 字符串。
2. 在 `APPS` 表中查找 ELF → `Process::from_elf()`。
3. 继承父进程调度参数，调用 `PManager::add(child_pid, child, parent_pid)` 建立父子关系。

#### mmap/munmap 迁移

- 复用 ch4 逻辑，但改为通过当前调度进程的 `PROCESSOR.get_mut().current()` 获取地址空间。
- 仍然在 `areas` 中检查重叠/存在性，并调用 `AddressSpace::map`/`unmap`。

### 待办

1. 评估 stride 调度在大量进程场景下的性能，考虑按需实现更高效的数据结构或饥饿检测。
2. 后续章节（ch6+) 关注线程/信号机制，与当前 `ProcThreadRel` 结构衔接。
3. 进一步完善 `PageManager::deallocate` 与 sbrk 收缩的物理页回收策略。*** End Patch
