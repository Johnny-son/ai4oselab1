# AI 对话记录：2026-02-11

- 主题：完成 ch4 编程作业（trace/mmap/munmap），解决三个栈溢出与权限 bug
- 使用的 AI 工具：GitHub Copilot（VS Code Agent Mode）

## 关键结论

- ch4 exercise 测试 16/16 通过，base 测试 6/6 通过。
- 从 Reference/ch4 复制到 Work/os/ch4，完成 workspace 依赖整合。
- `tg-kernel-vm` 拉取到 `Work/crates/tg-kernel-vm` 本地修改，新增 `unmap()` 和 `find_pte_mut()` 方法。
- 解决了**三个 bug**：启动栈溢出、调度栈溢出、trace 权限检查缺少 U 位。

---

## ch4 编程作业实现过程

### 任务目标

1. **重写 trace 系统调用**（ID 410）：引入虚存后需通过 `translate()` 翻译用户地址，并检查权限。
2. **实现 mmap**（ID 222）：申请物理内存映射到用户虚存，支持 R/W/X 权限。
3. **实现 munmap**（ID 215）：取消虚存映射，要求所有页已被映射。

### 项目搭建

1. 从 `Reference/ch4` 复制到 `Work/os/ch4`
2. 修改 `Cargo.toml`：包名 `tg-ch4` → `ch4`，依赖改为 workspace 引用
3. `tg-kernel-vm` 拉取到 `Work/crates/tg-kernel-vm`，在 workspace 中统一管理

### 修改的文件

#### 1. `Work/os/ch4/src/process.rs` — 扩展 Process 结构体

- 新增 `pub syscall_counts: [usize; SYSCALL_COUNT_MAX]`（`SYSCALL_COUNT_MAX = 512`）
- 新增 `record_syscall(&mut self, id: SyscallId)`：按 ID 索引递增
- 新增 `syscall_count(&self, id: usize) -> Option<usize>`：查询调用次数

与 ch3 的区别：ch3 通过 `Caller.entity` 指针传递计数数组，ch4 直接存在 `Process` 结构体中，通过 `PROCESSES` 全局列表访问。

#### 2. `Work/os/ch4/src/main.rs` — 实现三个系统调用 + 修复三个 bug

**Trace 实现：**
```rust
impl Trace for SyscallContext {
    fn trace(&self, caller: Caller, trace_request: usize, id: usize, data: usize) -> isize {
        const READABLE: VmFlags<Sv39> = build_flags("U__RV");
        const WRITABLE: VmFlags<Sv39> = build_flags("U_W_V");
        match trace_request {
            0 => process.address_space.translate::<u8>(VAddr::new(id), READABLE)
                    .map(|ptr| unsafe { *ptr.as_ptr() as isize }).unwrap_or(-1),
            1 => /* translate + write */,
            2 => process.syscall_count(id).map(|c| c as isize).unwrap_or(-1),
            _ => -1,
        }
    }
}
```

**mmap 实现：**
- 参数校验：addr 页对齐、prot 合法（`prot & !0x7 == 0` 且 `prot & 0x7 != 0`）
- 权限构建：`prot` 的 bit0/1/2 分别对应 R/W/X，转为 `"U___V"` 格式字符串再 `parse_flags()`
- 重叠检查：遍历 `address_space.areas` 判断 `[start_vpn, end_vpn)` 是否与已有区域重叠
- 调用 `address_space.map(range, &[], 0, flags)` 分配零页并映射

**munmap 实现：**
- 逐页检查是否在 `address_space.areas` 中存在映射，未映射则返回 -1
- 调用 `address_space.unmap(range)` 取消映射

#### 3. `Work/crates/tg-kernel-vm/src/space/mod.rs` — 新增 unmap 方法

```rust
pub fn unmap(&mut self, range: Range<VPN<Meta>>) {
    // 1. 从 areas 中移除范围（支持拆分）
    // 2. 逐页清除 PTE（find_pte_mut + write_bytes 清零）
    // 3. sfence.vma 刷新 TLB
}

fn find_pte_mut(&self, vpn: VPN<Meta>) -> Option<*mut Pte<Meta>> {
    // 三级页表遍历：从根页表沿 VPN[2] → VPN[1] → VPN[0] 找到叶子 PTE
}
```

### 踩坑记录

#### Bug 1：启动栈溢出（只检测到 1 个 app，然后卡死）

**现象**：`cargo run` 只打印 `detect app[0]`，然后无输出卡死。

**原因**：`Process` 结构体含 `syscall_counts: [usize; 512]` = 4KB。`Process::new()` 在栈上构造临时 `Process` 再 `Vec::push()`，原始启动栈 `6 * 4096 = 24KB` 不足。

**修复**：
```rust
// boot0! 宏：内核启动栈 24KB → 64KB
tg_linker::boot0!(rust_main; stack = 16 * 4096);
```

**教训**：ch3 也遇到过相同问题。含大数组的结构体在栈上临时构造时很容易溢出，裸机环境下栈溢出无任何提示，只会静默卡死。

#### Bug 2：调度线程栈溢出（StorePageFault）

**现象**：所有 app 检测成功，但进入 `schedule()` 后立即触发 `StorePageFault`，`stval` 接近 `0x4000000000`（调度栈顶）。

**原因**：调度栈原来只有 2 页（8KB），`schedule()` 函数的调用链（传送门切换 → syscall 分发 → trace/mmap 处理）栈深度超过 8KB。

**修复过程**：
- 先尝试 4 页 → 仍然 crash（`stval = 0x3fffffbff8`，距栈顶 16KB 处溢出）
- 最终增至 8 页（32KB）→ 正常运行

```rust
const SCHED_PAGES: usize = 8;
const PAGE: Layout = unsafe {
    Layout::from_size_align_unchecked(SCHED_PAGES << Sv39::PAGE_BITS, 1 << Sv39::PAGE_BITS)
};
```

#### Bug 3：trace 权限检查缺少 U 位（ch4_trace 断言失败）

**现象**：`ch4_trace` 测试中 `trace_read(isize::MAX)` 返回 `Some(0)` 而非 `None`。预期对用户不可见地址返回 -1。

**分析**：
- `isize::MAX = 0x7FFFFFFFFFFFFFFF`
- Sv39 虚拟地址只有 39 位，高位被截断 → 映射到 `VPN::MAX`
- `VPN::MAX` 恰好是**异界传送门页面**（`PROTAL_TRANSIT`）
- 传送门标志位为 `"__G_XWRV"`（无 U 位），内核可访问但用户不可见
- 原始 `READABLE = build_flags("RV")` 只检查 R+V，不检查 U → translate 成功

**修复**：
```rust
// 之前：只检查 R+V
const READABLE: VmFlags<Sv39> = build_flags("RV");
const WRITABLE: VmFlags<Sv39> = build_flags("W_V");

// 之后：必须检查 U 位，确保用户态可见
const READABLE: VmFlags<Sv39> = build_flags("U__RV");
const WRITABLE: VmFlags<Sv39> = build_flags("U_W_V");
```

**教训**：`translate()` 的 `flags.contains()` 检查要求被检查标志位是 PTE 标志的**子集**。不带 U 位检查时，传送门页面（有 R+V 但无 U）也会通过，造成安全漏洞。

### 设计对比：ch3 vs ch4 的 trace

| 方面 | ch3（无虚存） | ch4（Sv39 虚存） |
|------|-------------|-----------------|
| 地址含义 | 物理地址 | 虚拟地址 |
| 读取方式 | 直接解引用指针 | `translate()` 翻译 + 权限检查 |
| 权限检查 | 无 | 必须包含 U 位 |
| 计数传递 | `Caller.entity` 编码指针 | `PROCESSES` 全局列表索引 |
| 失败情况 | 理论上不会 | 地址不可见/权限不足返回 -1 |

### 测试结果

```
# exercise 测试
$ ./test.sh exercise
[PASS] found <Test trace OK!>
[PASS] found <Test mmap OK!>
... (共 16 项)
Test PASSED: 16/16
✓ ch4 练习测试通过

# base 测试
$ ./test.sh base
[PASS] found <Hello, world from user mode program!>
[PASS] found <Test power OK!>
... (共 6 项)
Test PASSED: 6/6
✓ ch4 基础测试通过
```

## 技术要点总结

### VmFlags 字符串格式

```
位置：  U  X  W  R  V
示例： "U__RV"  → 用户可读有效
       "U_W_V"  → 用户可写有效
       "UXWRV"  → 用户全权限
       "__G_XWRV" → 全局内核全权限（传送门）
```

- `build_flags()` 编译期常量，`parse_flags()` 运行期解析
- `VmFlags::contains()` 检查被检查标志是 PTE 标志的子集

### AddressSpace 关键 API

| 方法 | 用途 |
|------|------|
| `map(range, data, offset, flags)` | 分配物理页 + 拷贝数据 + 建立映射 |
| `map_extern(range, ppn, flags)` | 已有物理页，仅建立映射 |
| `unmap(range)` | 取消映射，清除 PTE，刷新 TLB |
| `translate::<T>(vaddr, flags)` | 虚拟地址翻译 + 权限检查 |
| `areas` | `Vec<Range<VPN>>`，记录所有已映射区域 |

## 待办

- 阅读 ch5 exercise，开始下一章节的编程作业（fork/exec/waitpid）。
