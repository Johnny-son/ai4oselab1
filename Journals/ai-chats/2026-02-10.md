# AI 对话记录：2026-02-10

- 主题：AI4OSE-lab1 目标理解、Cargo 镜像/SSL 问题、运行 tg-ch1~tg-ch3、完成 ch3 sys_trace 编程作业

## 关键结论

- `ai4ose-lab1-2026s` 只是实验说明入口；真正实验内容在 `tg-ch1~tg-ch8`。
- 镜像源从 USTC 切到 TUNA，并使用 `sparse+https` 后可正常下载依赖。
- QEMU 已可运行：tg-ch1 输出 Hello World；tg-ch2 批处理；tg-ch3 分时多任务。
- ch3 `sys_trace`（ID 410）编程作业已完成，exercise 测试 7/7 通过，base 测试 4/4 通过。

---

## ch3 sys_trace 编程作业实现过程

### 任务目标

实现系统调用 `sys_trace`（ID 410），支持三种功能：
- `trace_request=0`：读取用户内存指定地址处的 `u8` 值
- `trace_request=1`：写入 `u8` 值到用户内存指定地址
- `trace_request=2`：查询当前任务某个系统调用的调用次数（本次也计入统计）

### 设计思路

**核心难点**：`Trace` trait 的 `trace()` 方法实现在全局静态的 `SyscallContext` 上，无法直接访问当前任务的 `TaskControlBlock`。需要一种机制将每个任务的系统调用计数传递给 `trace()` 方法。

**解决方案**：利用 `Caller` 结构体的 `entity` 字段（`usize` 类型），在 `handle_syscall()` 中将当前任务的 `syscall_counts` 数组指针编码为 `usize` 传入 `Caller.entity`，在 `trace()` 实现中再将其还原为指针读取。

### 修改的文件

#### 1. `Work/os/ch3/src/task.rs` — 扩展 TaskControlBlock

- 新增常量 `SYSCALL_COUNT_MAX = 512`，覆盖所有系统调用号（最大 TRACE=410）
- `TaskControlBlock` 新增字段 `syscall_counts: [usize; 512]`（按 syscall ID 索引的计数数组）
- `ZERO` 常量和 `init()` 方法中同步初始化计数数组
- `handle_syscall()` 中：
  - **分发前先计数**：`self.syscall_counts[id.0] += 1`（确保 trace_request=2 查询时本次已计入）
  - 将 `syscall_counts` 数组指针通过 `Caller { entity: ptr as usize, flow: 0 }` 传递

#### 2. `Work/os/ch3/src/main.rs` — 实现 Trace trait + 增大内核栈

- **增大内核栈**：`(APP_CAPACITY + 2) * 8192` → `(APP_CAPACITY + 2) * 2 * 8192`（272KB → 544KB）
- 实现 `Trace for SyscallContext` 的 `trace()` 方法：
  ```rust
  match trace_request {
      0 => unsafe { *(id as *const u8) as isize },       // 读内存
      1 => { unsafe { *(id as *mut u8) = data as u8 }; 0 }, // 写内存
      2 => {                                               // 查计数
          let counts = caller.entity as *const usize;
          if id < 512 { unsafe { *counts.add(id) as isize } } else { 0 }
      }
      _ => -1,
  }
  ```

### 踩坑记录

1. **编译错误 E0282**：原代码 `let id = self.ctx.a(7).into()` 在新增 `id.0` 后类型推断失败，需显式标注 `let id: SyscallId = ...`。
2. **QEMU 卡死（栈溢出）**：新增 `syscall_counts` 后，每个 TCB 增大 4KB，32 个 TCB 数组总计约 393KB，超出原始内核栈 272KB，导致静默栈溢出。解决：将内核栈大小翻倍至 544KB。

### 测试结果

```
# exercise 测试
$ ./test.sh exercise
[PASS] found <get_time OK! (\d+)>
[PASS] found <Test sleep OK!>
[PASS] found <current time_msec = (\d+)>
[PASS] found <time_msec = (\d+) after sleeping (\d+) ticks, delta = (\d+)ms!>
[PASS] found <Test sleep1 passed!>
[PASS] found <string from task trace test>
[PASS] found <Test trace OK!>
Test PASSED: 7/7
✓ ch3 练习测试通过

# base 测试（确认未破坏原有功能）
$ ./test.sh base
[PASS] found <Test write A OK!>
[PASS] found <Test write B OK!>
[PASS] found <Test write C OK!>
[PASS] not found <FAIL: T.T>
Test PASSED: 4/4
✓ ch3 基础测试通过
```

## 待办

- 阅读 ch4 exercise，开始下一章节的编程作业。
